<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Etherial Tarot - Three.js & MediaPipe</title>
    <style>
        :root { --accent: #d4af37; --bg: #111; --glass: rgba(20, 20, 20, 0.85); }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Cinzel', serif; color: #eee; user-select: none; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        
        /* Header */
        header { text-align: center; pointer-events: auto; }
        h1 { margin: 0; color: var(--accent); text-shadow: 0 0 10px rgba(212, 175, 55, 0.5); font-weight: 400; letter-spacing: 2px; }
        .controls { margin-top: 10px; display: flex; justify-content: center; gap: 15px; }
        button { background: var(--glass); border: 1px solid var(--accent); color: var(--accent); padding: 5px 15px; cursor: pointer; text-transform: uppercase; transition: 0.3s; pointer-events: auto; font-family: inherit; }
        button:hover, button.active { background: var(--accent); color: #000; box-shadow: 0 0 15px var(--accent); }

        /* History Panel */
        #history-panel { position: absolute; top: 80px; left: 20px; width: 280px; max-height: 70%; overflow-y: auto; background: var(--glass); border-left: 2px solid var(--accent); padding: 10px; pointer-events: auto; opacity: 0.9; transition: transform 0.3s; transform: translateX(-320px); }
        #history-panel.show { transform: translateX(0); }
        .history-item { border-bottom: 1px solid #444; padding: 10px 0; font-size: 0.9em; display: flex; align-items: center; gap: 10px; }
        .history-item img { width: 30px; height: 50px; object-fit: cover; border: 1px solid #666; }
        .history-info strong { color: var(--accent); display: block; }
        .history-info em { font-size: 0.8em; color: #aaa; }
        .history-toggle { position: fixed; left: 20px; top: 20px; z-index: 100; pointer-events: auto; }

        /* Status & Meaning Display */
        #active-card-display { text-align: center; pointer-events: none; margin-bottom: 40px; transition: opacity 0.5s; opacity: 0; }
        #active-card-display.visible { opacity: 1; }
        #card-name { font-size: 2em; color: var(--accent); margin: 0; text-transform: uppercase; }
        #card-meaning { font-size: 1.1em; max-width: 600px; margin: 10px auto; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; }
        
        /* Loading/Cursor */
        #loader { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--accent); font-size: 1.5em; z-index: 999; }
        #cursor-follower { position: fixed; width: 20px; height: 20px; border: 2px solid var(--accent); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 900; transition: width 0.2s, background 0.2s; display: none; }
        #cursor-follower.pinch { background: var(--accent); width: 10px; height: 10px; }
        
        /* Hidden Video for MediaPipe */
        #video-source { display: none; }
        canvas { display: block; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">Initializing Oracle...</div>
    <div id="cursor-follower"></div>

    <div id="ui-layer">
        <header>
            <button class="history-toggle" onclick="toggleHistory()">üìú History</button>
            <h1>Arcana Divina</h1>
            <div class="controls">
                <button id="btn-hand" onclick="setMode('hand')">üñê Hand Tracking</button>
                <button id="btn-mouse" onclick="setMode('mouse')">üñ±Ô∏è Mouse Mode</button>
            </div>
        </header>
        
        <div id="history-panel"><h3>Readings</h3><div id="history-content"></div></div>

        <div id="active-card-display">
            <h2 id="card-name"></h2>
            <div id="card-meaning"></div>
        </div>
    </div>

    <video id="video-source" playsinline></video>

<script>
/** * TAROT DATA: Major Arcana (Full Deck 0-21)
 * Using a public GitHub raw proxy for Rider-Waite images
 */
const BASE_URL = "https://upload.wikimedia.org/wikipedia/commons";
const CARD_BACK_URL = "https://i.pinimg.com/564x/a0/04/cb/a004cb6801901a1d94895088c4712f5a.jpg"; 

const TAROT_DECK = [
    { id: 0, name: "The Fool", url: "/9/90/RWS_Tarot_00_Fool.jpg", 
      upright: "Beginnings, innocence, spontaneity, a free spirit", reversed: "Holding back, recklessness, risk-taking" },
    { id: 1, name: "The Magician", url: "/d/de/RWS_Tarot_01_Magician.jpg", 
      upright: "Manifestation, resourcefulness, power, inspired action", reversed: "Manipulation, poor planning, untapped talents" },
    { id: 2, name: "The High Priestess", url: "/8/88/RWS_Tarot_02_High_Priestess.jpg", 
      upright: "Intuition, sacred knowledge, divine feminine, the subconscious mind", reversed: "Secrets, disconnected from intuition, withdrawal and silence" },
    { id: 3, name: "The Empress", url: "/d/d2/RWS_Tarot_03_Empress.jpg", 
      upright: "Femininity, beauty, nature, nurturing, abundance", reversed: "Creative block, dependence on others" },
    { id: 4, name: "The Emperor", url: "/c/c3/RWS_Tarot_04_Emperor.jpg", 
      upright: "Authority, establishment, structure, a father figure", reversed: "Domination, excessive control, lack of discipline" },
    { id: 5, name: "The Hierophant", url: "/8/8d/RWS_Tarot_05_Hierophant.jpg", 
      upright: "Spiritual wisdom, religious beliefs, conformity, tradition", reversed: "Personal beliefs, freedom, challenging the status quo" },
    { id: 6, name: "The Lovers", url: "/3/3a/RWS_Tarot_06_Lovers.jpg", 
      upright: "Love, harmony, relationships, values alignment, choices", reversed: "Self-love, disharmony, imbalance, misalignment of values" },
    { id: 7, name: "The Chariot", url: "/9/9b/RWS_Tarot_07_Chariot.jpg", 
      upright: "Control, willpower, success, action, determination", reversed: "Self-discipline, opposition, lack of direction" },
    { id: 8, name: "Strength", url: "/f/f5/RWS_Tarot_08_Strength.jpg", 
      upright: "Strength, courage, persuasion, influence, compassion", reversed: "Inner strength, self-doubt, low energy, raw emotion" },
    { id: 9, name: "The Hermit", url: "/4/4d/RWS_Tarot_09_Hermit.jpg", 
      upright: "Soul-searching, introspection, being alone, inner guidance", reversed: "Isolation, loneliness, withdrawal" },
    { id: 10, name: "Wheel of Fortune", url: "/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", 
      upright: "Good luck, karma, life cycles, destiny, a turning point", reversed: "Bad luck, resistance to change, breaking cycles" },
    // --- Added Missing Cards (11-21) ---
    { id: 11, name: "Justice", url: "/e/e0/RWS_Tarot_11_Justice.jpg", 
      upright: "Justice, fairness, truth, cause and effect, law", reversed: "Unfairness, lack of accountability, dishonesty" },
    { id: 12, name: "The Hanged Man", url: "/2/2b/RWS_Tarot_12_Hanged_Man.jpg", 
      upright: "Pause, surrender, letting go, new perspectives", reversed: "Delays, resistance, stalling, indecision" },
    { id: 13, name: "Death", url: "/d/d7/RWS_Tarot_13_Death.jpg", 
      upright: "Endings, change, transformation, transition", reversed: "Resistance to change, personal transformation, inner purging" },
    { id: 14, name: "Temperance", url: "/f/f8/RWS_Tarot_14_Temperance.jpg", 
      upright: "Balance, moderation, patience, purpose", reversed: "Imbalance, excess, self-healing, re-alignment" },
    { id: 15, name: "The Devil", url: "/5/55/RWS_Tarot_15_Devil.jpg", 
      upright: "Shadow self, attachment, addiction, restriction", reversed: "Releasing limiting beliefs, exploring dark thoughts, detachment" },
    { id: 16, name: "The Tower", url: "/5/53/RWS_Tarot_16_Tower.jpg", 
      upright: "Sudden change, upheaval, chaos, revelation, awakening", reversed: "Personal transformation, fear of change, averting disaster" },
    { id: 17, name: "The Star", url: "/d/db/RWS_Tarot_17_Star.jpg", 
      upright: "Hope, faith, purpose, renewal, spirituality", reversed: "Lack of faith, despair, self-trust, disconnection" },
    { id: 18, name: "The Moon", url: "/7/7f/RWS_Tarot_18_Moon.jpg", 
      upright: "Illusion, fear, anxiety, subconscious, intuition", reversed: "Release of fear, repressed emotion, inner confusion" },
    { id: 19, name: "The Sun", url: "/1/17/RWS_Tarot_19_Sun.jpg", 
      upright: "Positivity, fun, warmth, success, vitality", reversed: "Inner child, feeling down, overly optimistic" },
    { id: 20, name: "Judgement", url: "/d/dd/RWS_Tarot_20_Judgement.jpg", 
      upright: "Judgement, rebirth, inner calling, absolution", reversed: "Self-doubt, inner critic, ignoring the call" },
    { id: 21, name: "The World", url: "/f/ff/RWS_Tarot_21_World.jpg", 
      upright: "Completion, integration, accomplishment, travel", reversed: "Seeking personal closure, short-cuts, delays" }
];

// ------------------------------------------------------------------
// GLOBAL STATE
// ------------------------------------------------------------------
const state = {
    mode: 'mouse', // 'hand' or 'mouse'
    gesture: 'OPEN', // OPEN, PINCH, FIST, POINT
    cursor: new THREE.Vector2(), // Screen space -1 to 1
    isGrabbing: false,
    grabbedObject: null,
    deck: [...TAROT_DECK], // Mutable copy (available cards)
    deckCards: [], // Array of TarotCard instances in the deck (visual representation)
    history: [],
    currentCard: null, // Currently selected card
    deckRotation: 0, // Rotation angle of the deck circle (in radians)
    isRotating: false, // Whether user is rotating the deck
    lastCursorX: 0, // Last cursor X position for rotation calculation
    selectedCardIndex: -1, // Index of selected card in deck
    selectedCardConfirmed: false // Whether the selected card has been confirmed (flipped)
};

// ------------------------------------------------------------------
// THREE.JS SETUP
// ------------------------------------------------------------------
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x111111, 0.02);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 5);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);
const spotLight = new THREE.SpotLight(0xd4af37, 1);
spotLight.position.set(5, 10, 7);
spotLight.castShadow = true;
scene.add(spotLight);
const pointLight = new THREE.PointLight(0x4444ff, 0.5);
pointLight.position.set(-5, 0, 2);
scene.add(pointLight);

// Raycaster
const raycaster = new THREE.Raycaster();
const mousePlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
const rayIntersectPoint = new THREE.Vector3();

// ------------------------------------------------------------------
// CARD LOGIC
// ------------------------------------------------------------------
const textureLoader = new THREE.TextureLoader();
textureLoader.setCrossOrigin('anonymous'); // Enable CORS for external images
// Placeholder texture for loading errors
const placeholderData = new Uint8Array([150, 100, 50, 150, 100, 50, 150, 100, 50, 150, 100, 50]); // 2x2 RGB texture
const placeholderTex = new THREE.DataTexture(placeholderData, 2, 2, THREE.RGBFormat);
placeholderTex.needsUpdate = true;

const SAFE_CARD_BACK_URL = "https://upload.wikimedia.org/wikipedia/commons/5/5a/Tarot_Back_Design.jpg";

class TarotCard {
    constructor(cardData = null, isInDeck = false, deckIndex = 0) {
        this.data = cardData;
        
        // Ê¥óÁâåÔºöÂàùÂßãÂåñÊó∂Âç≥ÂÜ≥ÂÆöÊ≠£ÈÄÜ‰Ωç
        const isReversed = Math.random() < 0.5;
        this.orientation = isReversed ? 'reversed' : 'upright';

        this.mesh = null;
        this.isInDeck = isInDeck; 
        this.deckIndex = deckIndex; 
        this.isDrawn = false; 
        
        this.init();
    }

    init() {
        // Â¶ÇÊûúÊòØÊäΩÊñ∞ÁâåÔºå‰ªéÁâåÂ∫ìÈöèÊú∫Âèñ
        if (!this.data) {
            if (state.deck.length === 0) {
                alert("The deck is empty. Refresh to restart.");
                return;
            }
            const index = Math.floor(Math.random() * state.deck.length);
            this.data = state.deck[index];
            if (!this.isInDeck) {
                state.deck.splice(index, 1);
            }
        }

        this.group = new THREE.Group();
        
        // ------------------------------------------------
        // 1. ÂàõÂª∫ÊùêË¥® (ÂÖ≥ÈîÆ‰øÆÂ§ç)
        // ------------------------------------------------
        
        // Ê≠£Èù¢ÊùêË¥®ÔºöÂàùÂßãËÆæ‰∏∫Á¥´Ëâ≤ÔºåÈò≤Ê≠¢ÂõæÁâáÊú™Âä†ËΩΩÊó∂ÂÖ®Èªë
        const matFront = new THREE.MeshStandardMaterial({ 
            color: 0x660066, 
            side: THREE.DoubleSide 
        });

        // ËÉåÈù¢ÊùêË¥®ÔºöÂàùÂßãËÆæ‰∏∫ÈáëËâ≤Ôºå‰Ωú‰∏∫‰øùÂ∫ïÊòæÁ§∫
        const matBack = new THREE.MeshStandardMaterial({ 
            color: 0xd4af37, 
            side: THREE.DoubleSide,
            roughness: 0.7,
            metalness: 0.3
        });

        // ------------------------------------------------
        // 2. ÂºÇÊ≠•Âä†ËΩΩÁ∫πÁêÜ
        // ------------------------------------------------
        
        // Âä†ËΩΩÊ≠£Èù¢Âõæ
        textureLoader.load(
            BASE_URL + this.data.url,
            (tex) => {
                tex.flipY = false;
                matFront.map = tex;
                matFront.color.setHex(0xffffff); // Âä†ËΩΩÊàêÂäüÂêéÔºåÊääÈ¢úËâ≤ÊîπÂõûÁôΩËâ≤ÔºåÊòæÁ§∫ÂéüÂõæËâ≤ÂΩ©
                matFront.needsUpdate = true;
            },
            undefined,
            (err) => console.warn("Front load error", err)
        );

        // Âä†ËΩΩËÉåÈù¢Âõæ (‰ΩøÁî®Êñ∞ÁöÑ SAFE_CARD_BACK_URL)
        textureLoader.load(
            SAFE_CARD_BACK_URL, 
            (tex) => {
                tex.flipY = false;
                matBack.map = tex;
                matBack.color.setHex(0xffffff); // Âä†ËΩΩÊàêÂäüÂêéÔºåÊääÈ¢úËâ≤ÊîπÂõûÁôΩËâ≤
                matBack.needsUpdate = true;
            },
            undefined,
            (err) => console.warn("Back load error", err)
        );

        // ------------------------------------------------
        // 3. ÂàõÂª∫Âá†‰Ωï‰Ωì‰∏é Mesh
        // ------------------------------------------------
        const geom = new THREE.PlaneGeometry(1.8, 3.0);
        
        // ËÉåÈù¢ Mesh (ÊóãËΩ¨ 180 Â∫¶ÊúùÂêé)
        const backMesh = new THREE.Mesh(geom, matBack);
        backMesh.rotation.y = Math.PI;
        
        // Ê≠£Èù¢ Mesh (ÊúùÂâç)
        const frontMesh = new THREE.Mesh(geom, matFront);
        frontMesh.rotation.y = 0;
        
        // Â∫îÁî®Ê≠£ÈÄÜ‰ΩçÊóãËΩ¨ (ËßÜËßâË°®Áé∞)
        if (this.orientation === 'reversed') {
            frontMesh.rotation.z = Math.PI;
        } else {
            frontMesh.rotation.z = 0;
        }
        
        // ------------------------------------------------
        // 4. ÂàùÂßãÂèØËßÅÊÄß‰∏é‰ΩçÁΩÆ
        // ------------------------------------------------
        if (this.isInDeck) {
            backMesh.visible = true;
            frontMesh.visible = false;
        } else {
            backMesh.visible = false;
            frontMesh.visible = true;
        }
        
        this.group.add(backMesh);
        this.group.add(frontMesh);
        
        this.backMesh = backMesh;
        this.frontMesh = frontMesh;
        
        // ÊäΩÂá∫ÁöÑÁâåÁöÑÂàùÂßãÈöèÊú∫‰ΩçÁΩÆ
        if (!this.isInDeck) {
            this.group.position.set((Math.random()-0.5)*4, (Math.random()-0.5)*2, -2);
            this.group.rotation.y = Math.PI; 
            this.group.rotation.z = (Math.random() - 0.5) * 0.5;
        }

        scene.add(this.group);
        
        this.floatOffset = Math.random() * 100;
        this.velocity = new THREE.Vector3();
    }
    
    select() {
        if (!this.isInDeck) return;
        if (this.backMesh) this.backMesh.visible = true;
        if (this.frontMesh) this.frontMesh.visible = false;
        state.selectedCardIndex = this.deckIndex;
        state.selectedCardConfirmed = false;
        state.currentCard = this;
    }
    
    confirm() {
        if (!this.isInDeck || state.selectedCardIndex !== this.deckIndex) return;
        if (this.backMesh) this.backMesh.visible = false;
        if (this.frontMesh) this.frontMesh.visible = true;
        
        state.selectedCardConfirmed = true;
        
        const meaning = this.orientation === 'upright' ? this.data.reversed : this.data.upright;
        const statusText = this.orientation === 'reversed' ? 'Upright' : 'Reverse';
        const displayName = `${this.data.name} (${statusText})`;
        
        document.getElementById('card-name').innerText = displayName;
        document.getElementById('card-meaning').innerText = meaning;
        document.getElementById('active-card-display').classList.add('visible');
    }
    
    deselect() {
        if (this.backMesh) this.backMesh.visible = true;
        if (this.frontMesh) this.frontMesh.visible = false;
        state.selectedCardIndex = -1;
        state.selectedCardConfirmed = false;
        if (state.currentCard === this) state.currentCard = null;
        document.getElementById('active-card-display').classList.remove('visible');
    }

    draw() {} // Âç†‰Ωç

    update(time) {
        if (this.isInDeck) {
            if (state.selectedCardIndex !== this.deckIndex) {
                this.group.position.y += Math.sin(time + this.floatOffset) * 0.001; // ÂæÆÂä®
            }
            return;
        }
        if (state.isGrabbing && state.grabbedObject === this.group) return;
        this.group.position.y += Math.sin(time + this.floatOffset) * 0.002;
    }

    burn() {
        createAshEffect(this.group.children[1]); 
        
        const meaning = this.orientation === 'upright' ? this.data.reversed : this.data.upright;
        const statusText = this.orientation === 'reversed' ? 'Upright' : 'Reverse';
        const displayName = `${this.data.name} (${statusText})`;
        
        document.getElementById('card-name').innerText = displayName;
        document.getElementById('card-meaning').innerText = meaning;
        document.getElementById('active-card-display').classList.add('visible');
        
        addToHistory(this.data.url, displayName, meaning);

        scene.remove(this.group);
        state.currentCard = null;
    }
}

let currentCard = null;

// ------------------------------------------------------------------
// ASH / PARTICLE EFFECT
// ------------------------------------------------------------------
const ashes = [];

function createAshEffect(targetMesh) {
    const geom = targetMesh.geometry.clone();
    const posAttribute = geom.attributes.position;
    const count = posAttribute.count;
    
    // Create particle geometry
    const particleGeom = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const velocities = new Float32Array(count * 3);
    const lifetimes = new Float32Array(count);
    
    // World transforms
    targetMesh.parent.updateMatrixWorld();
    const worldMatrix = targetMesh.matrixWorld;

    for (let i = 0; i < count; i++) {
        const v = new THREE.Vector3(posAttribute.getX(i), posAttribute.getY(i), posAttribute.getZ(i));
        v.applyMatrix4(worldMatrix); 
        
        positions[i*3] = v.x;
        positions[i*3+1] = v.y;
        positions[i*3+2] = v.z;
        
        velocities[i*3] = (Math.random() - 0.5) * 0.02; 
        velocities[i*3+1] = Math.random() * 0.05 + 0.01; 
        velocities[i*3+2] = (Math.random() - 0.5) * 0.02; 
        
        lifetimes[i] = 1.0; 
    }
    
    particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: 0xffaa00,
        size: 0.05,
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending,
        map: targetMesh.material.map 
    });

    const ashSystem = {
        mesh: new THREE.Points(particleGeom, material),
        velocities: velocities,
        lifetimes: lifetimes,
        update: function() {
            const positions = this.mesh.geometry.attributes.position.array;
            let alive = false;
            
            for(let i=0; i<lifetimes.length; i++) {
                if (lifetimes[i] > 0) {
                    alive = true;
                    // Move
                    positions[i*3] += this.velocities[i*3] + Math.sin(Date.now()*0.005 + i)*0.002;
                    positions[i*3+1] += this.velocities[i*3+1];
                    positions[i*3+2] += this.velocities[i*3+2];
                    
                    // Fade
                    lifetimes[i] -= Math.random() * 0.02;
                }
            }
            this.mesh.geometry.attributes.position.needsUpdate = true;
            this.mesh.material.opacity = Math.max(0, this.mesh.material.opacity - 0.01);
            
            return this.mesh.material.opacity > 0;
        }
    };
    
    scene.add(ashSystem.mesh);
    ashes.push(ashSystem);
}

// ------------------------------------------------------------------
// INPUT & LOGIC
// ------------------------------------------------------------------

function setMode(newMode) {
    state.mode = newMode;
    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${newMode}`).classList.add('active');
    
    const cursor = document.getElementById('cursor-follower');
    if (newMode === 'hand') {
        initCamera();
        cursor.style.display = 'block';
    } else {
        stopCamera();
        cursor.style.display = 'none'; 
    }
}

// Mouse Listeners
window.addEventListener('mousemove', (e) => {
    if (state.mode === 'mouse') {
        const newX = (e.clientX / window.innerWidth) * 2 - 1;
        const newY = -(e.clientY / window.innerHeight) * 2 + 1;
        
        state.cursor.x = newX;
        state.cursor.y = newY;
        
        const rotationSpeed = 0.03;
        if (newX > 0.1) {
            state.deckRotation += rotationSpeed * newX;
        } else if (newX < -0.1) {
            state.deckRotation += rotationSpeed * newX;
        }
    }
});

window.addEventListener('mousedown', (e) => {
    if (state.mode === 'mouse' && e.button === 0) { 
        state.gesture = 'PINCH'; 
        handleInteraction();
    }
});
window.addEventListener('mouseup', (e) => {
    if (state.mode === 'mouse') {
        state.gesture = 'OPEN';
        state.isGrabbing = false;
        state.grabbedObject = null;
    }
});
window.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (state.mode === 'mouse') {
        state.gesture = 'FIST'; 
        handleInteraction();
        setTimeout(() => { state.gesture = 'OPEN'; }, 200); 
    }
});

// Update deck layout in a circle
function updateDeckLayout() {
    const radius = 7.0; 
    const totalCards = state.deckCards.length;
    
    if (totalCards === 0) return;
    
    state.deckCards.forEach((card, index) => {
        if (!card.isInDeck) return;
        
        const baseAngle = (index / totalCards) * Math.PI * 2 - Math.PI / 2;
        const angle = baseAngle + state.deckRotation;
        
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = -1; 
        
        if (state.selectedCardIndex === card.deckIndex) {
            const targetX = 0;
            const targetY = 0;
            const targetZ = 2; 
            card.group.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.1);
            card.group.rotation.y = 0; 
        } else {
            card.group.position.set(x, y, z);
            const lookAtCenter = Math.atan2(-x, -z);
            card.group.rotation.y = lookAtCenter;
        }
        
        if (state.selectedCardIndex === card.deckIndex && state.selectedCardConfirmed) {
            if (card.backMesh) card.backMesh.visible = false;
            if (card.frontMesh) card.frontMesh.visible = true;
        } else {
            if (card.backMesh) card.backMesh.visible = true;
            if (card.frontMesh) card.frontMesh.visible = false;
        }
        
        card.group.rotation.x = 0;
        card.group.rotation.z = 0;
    });
}

function handleInteraction() {
    raycaster.setFromCamera(state.cursor, camera);
    
    if (state.gesture === 'PINCH') {
        const intersects = raycaster.intersectObjects(scene.children, true); 
        const hit = intersects.find(i => i.object.parent && i.object.parent.type === 'Group');
        
        if (hit && !state.isGrabbing) {
            const hitGroup = hit.object.parent;
            const deckCard = state.deckCards.find(card => card.group === hitGroup);
            
            if (deckCard && deckCard.isInDeck) {
                if (state.currentCard && state.selectedCardConfirmed) {
                    state.currentCard.deselect();
                    state.isGrabbing = false;
                    state.grabbedObject = null;
                    document.getElementById('cursor-follower').classList.remove('pinch');
                    return;
                }
                
                if (state.selectedCardIndex !== deckCard.deckIndex) {
                    if (state.selectedCardIndex >= 0) {
                        const prevCard = state.deckCards.find(c => c.deckIndex === state.selectedCardIndex);
                        if (prevCard) prevCard.deselect();
                    }
                    deckCard.select();
                }
                state.isGrabbing = true;
                state.grabbedObject = hitGroup;
                document.getElementById('cursor-follower').classList.add('pinch');
            } else if (state.currentCard && state.currentCard.group === hitGroup && !state.currentCard.isInDeck) {
                state.isGrabbing = true;
                state.grabbedObject = hitGroup;
                document.getElementById('cursor-follower').classList.add('pinch');
            } else if (state.currentCard && state.selectedCardConfirmed) {
                state.currentCard.deselect();
                state.isGrabbing = false;
                state.grabbedObject = null;
                document.getElementById('cursor-follower').classList.remove('pinch');
            }
        } else if (!hit && state.currentCard && state.selectedCardConfirmed) {
            state.currentCard.deselect();
            state.isGrabbing = false;
            state.grabbedObject = null;
            document.getElementById('cursor-follower').classList.remove('pinch');
        }
    } else {
        state.isGrabbing = false;
        state.grabbedObject = null;
        document.getElementById('cursor-follower').classList.remove('pinch');
    }

    if (state.isGrabbing && state.grabbedObject && state.currentCard && !state.currentCard.isInDeck) {
        const targetZ = 1.5; 
        raycaster.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0,0,1), -targetZ), rayIntersectPoint);
        
        state.grabbedObject.position.lerp(rayIntersectPoint, 0.1);
        
        if (state.grabbedObject.position.z > 0) {
            state.grabbedObject.rotation.y = THREE.MathUtils.lerp(state.grabbedObject.rotation.y, 0, 0.1);
        }
        
        state.grabbedObject.rotation.z = (state.grabbedObject.position.x - rayIntersectPoint.x) * -2;
        state.grabbedObject.rotation.x = (state.grabbedObject.position.y - rayIntersectPoint.y) * 2;
    }

    if (state.gesture === 'FIST') {
        if (state.currentCard && state.currentCard.isInDeck && !state.selectedCardConfirmed) {
            state.currentCard.confirm();
            state.isGrabbing = false;
            state.grabbedObject = null;
        } 
        else if (state.currentCard && !state.currentCard.isInDeck && state.currentCard.group.position.z > 0.5) {
            state.currentCard.burn();
            state.isGrabbing = false;
            state.grabbedObject = null;
        }
    }
}

// ------------------------------------------------------------------
// MEDIAPIPE HANDS
// ------------------------------------------------------------------
let hands;
let cameraUtils;

function initCamera() {
    if (cameraUtils) {
        document.getElementById('video-source').play();
        return;
    }

    const videoElement = document.getElementById('video-source');
    
    hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onHandResults);

    try {
        cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();
        document.getElementById('loader').style.display = 'none';
    } catch (e) {
        console.error(e);
        alert("Camera failed. Switching to Mouse Mode.");
        setMode('mouse');
    }
}

function stopCamera() {
    const vid = document.getElementById('video-source');
    vid.pause();
}

function onHandResults(results) {
    if (state.mode !== 'hand') return;

    const cursor = document.getElementById('cursor-follower');

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        const x = 1 - landmarks[8].x; 
        const y = landmarks[8].y;
        const newCursorX = (x * 2) - 1;
        const newCursorY = -(y * 2) + 1;

        state.gesture = detectGesture(landmarks);
        
        if (state.gesture === 'OPEN' && !state.isGrabbing && state.selectedCardIndex === -1) {
            const rotationSpeed = 0.05; 
            const deadZone = 0.15; 
            
            if (newCursorX > deadZone) {
                state.deckRotation += rotationSpeed * (newCursorX - deadZone);
            } else if (newCursorX < -deadZone) {
                state.deckRotation += rotationSpeed * (newCursorX + deadZone);
            }
        }

        state.cursor.set(newCursorX, newCursorY);
        state.lastCursorX = newCursorX;
        
        cursor.style.left = `${x * 100}%`;
        cursor.style.top = `${y * 100}%`;

        if(state.gesture === 'PINCH') cursor.style.backgroundColor = 'red';
        else if(state.gesture === 'FIST') cursor.style.backgroundColor = 'blue';
        else cursor.style.backgroundColor = 'var(--accent)';

        handleInteraction();
    } else {
        state.isRotating = false;
    }
}

function detectGesture(lm) {
    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
    if (pinchDist < 0.05) return 'PINCH';

    const tips = [8, 12, 16, 20];
    let curledCount = 0;
    tips.forEach(t => {
        const dTip = Math.hypot(lm[t].x - lm[0].x, lm[t].y - lm[0].y);
        const dPip = Math.hypot(lm[t-2].x - lm[0].x, lm[t-2].y - lm[0].y); 
        if (dTip < dPip) curledCount++;
    });

    if (curledCount >= 3) return 'FIST';

    return 'OPEN';
}

// ------------------------------------------------------------------
// UI LOGIC
// ------------------------------------------------------------------
function addToHistory(url, name, meaning) {
    const panel = document.getElementById('history-content');
    const item = document.createElement('div');
    item.className = 'history-item';
    item.innerHTML = `
        <img src="${BASE_URL + url}" />
        <div class="history-info">
            <strong>${name}</strong>
            <em>${meaning.substring(0, 50)}...</em>
        </div>
    `;
    panel.prepend(item);
}

function toggleHistory() {
    document.getElementById('history-panel').classList.toggle('show');
}

// ------------------------------------------------------------------
// MAIN LOOP
// ------------------------------------------------------------------
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);

    const time = clock.getElapsedTime();

    updateDeckLayout();

    state.deckCards.forEach(card => card.update(time));
    
    if (state.currentCard && !state.currentCard.isInDeck) {
        state.currentCard.update(time);
    }

    for (let i = ashes.length - 1; i >= 0; i--) {
        const alive = ashes[i].update();
        if (!alive) {
            scene.remove(ashes[i].mesh);
            ashes.splice(i, 1);
        }
    }

    renderer.render(scene, camera);
}

// ------------------------------------------------------------------
// DECK INITIALIZATION
// ------------------------------------------------------------------
function initializeDeck() {
    state.deckCards.forEach(card => {
        if (card.group && card.group.parent) {
            scene.remove(card.group);
        }
    });
    
    state.deck = [...TAROT_DECK];
    state.deckCards = [];
    state.currentCard = null;
    state.deckRotation = 0;
    state.selectedCardIndex = -1;
    state.selectedCardConfirmed = false;
    
    TAROT_DECK.forEach((cardData, index) => {
        const card = new TarotCard(cardData, true, index);
        state.deckCards.push(card);
    });
    
    updateDeckLayout();
    
    console.log(`Initialized deck with ${state.deckCards.length} cards`);
}

document.getElementById('loader').innerText = "Loading Deck...";
setTimeout(() => {
    initializeDeck();
    setMode('mouse'); 
    document.getElementById('loader').style.display = 'none';
}, 1000);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();

</script>
</body>
</html>